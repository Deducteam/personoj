require open personoj.lhol personoj.logical personoj.pvs_cert
personoj.eq personoj.restrict personoj.coercions;
require personoj.telescope as TL;
require personoj.extra.arity-tools as A;
require open personoj.nat;
require open personoj.cast;
// Theory constant_param
require pvs.prelude.booleans as booleans;
require pvs.prelude.equalities as equalities;
require pvs.prelude.notequal as notequal;
require pvs.prelude.if_def as if_def;
require pvs.prelude.boolean_props as boolean_props;
require pvs.prelude.xor_def as xor_def;
require pvs.prelude.quantifier_props as quantifier_props;
require pvs.prelude.defined_types as defined_types;
require pvs.prelude.exists1 as exists1;
require pvs.prelude.equality_props as equality_props;
require pvs.prelude.if_props as if_props;
require pvs.prelude.functions as functions;
require pvs.prelude.functions_alt as functions_alt;
require pvs.prelude.transpose as transpose;
require pvs.prelude.restrict as restrict;
require pvs.prelude.restrict_props as restrict_props;
require pvs.prelude.extend as extend;
require pvs.prelude.extend_bool as extend_bool;
require pvs.prelude.extend_props as extend_props;
require pvs.prelude.extend_func_props as extend_func_props;
require pvs.prelude.K_conversion as K_conversion;
require pvs.prelude.K_props as K_props;
require pvs.prelude.identity as identity;
require pvs.prelude.identity_props as identity_props;
require pvs.prelude.relations as relations;
require pvs.prelude.orders as orders;
require pvs.prelude.orders_alt as orders_alt;
require pvs.prelude.restrict_order_props as restrict_order_props;
require pvs.prelude.extend_order_props as extend_order_props;
require pvs.prelude.wf_induction as wf_induction;
require pvs.prelude.measure_induction as measure_induction;
require pvs.prelude.epsilons as epsilons;
require pvs.prelude.decl_params as decl_params;
require pvs.prelude.sets as sets;
require pvs.prelude.sets_lemmas as sets_lemmas;
require pvs.prelude.function_inverse_def as function_inverse_def;
require pvs.prelude.function_inverse as function_inverse;
require pvs.prelude.function_inverse_alt as function_inverse_alt;
require pvs.prelude.function_image as function_image;
require pvs.prelude.function_props as function_props;
require pvs.prelude.function_props_alt as function_props_alt;
require pvs.prelude.function_props2 as function_props2;
require pvs.prelude.relation_defs as relation_defs;
require pvs.prelude.relation_props as relation_props;
require pvs.prelude.relation_props2 as relation_props2;
require pvs.prelude.relation_converse_props as relation_converse_props;
require pvs.prelude.indexed_sets as indexed_sets;
require pvs.prelude.operator_defs as operator_defs;
require pvs.prelude.numbers as numbers;
require pvs.prelude.number_fields as number_fields;
require pvs.prelude.reals as reals;
require pvs.prelude.real_axioms as real_axioms;
require pvs.prelude.bounded_real_defs as bounded_real_defs;
require pvs.prelude.bounded_real_defs_alt as bounded_real_defs_alt;
require pvs.prelude.real_types as real_types;
require pvs.prelude.rationals as rationals;
require pvs.prelude.integers as integers;
require pvs.prelude.naturalnumbers as naturalnumbers;
require pvs.prelude.min_nat as min_nat;
require pvs.prelude.real_defs as real_defs;
require pvs.prelude.real_props as real_props;
require pvs.prelude.extra_real_props as extra_real_props;
require pvs.prelude.extra_tegies as extra_tegies;
require pvs.prelude.rational_props as rational_props;
require pvs.prelude.integer_props as integer_props;
require pvs.prelude.floor_ceil as floor_ceil;
require pvs.prelude.exponentiation as exponentiation;
require pvs.prelude.euclidean_division as euclidean_division;
require pvs.prelude.divides as divides;
require pvs.prelude.modulo_arithmetic as modulo_arithmetic;
require pvs.prelude.subrange_inductions as subrange_inductions;
require pvs.prelude.bounded_int_inductions as bounded_int_inductions;
require pvs.prelude.bounded_nat_inductions as bounded_nat_inductions;
require pvs.prelude.subrange_type as subrange_type;
require pvs.prelude.int_types as int_types;
require pvs.prelude.nat_types as nat_types;
require pvs.prelude.nat_fun_props as nat_fun_props;
require pvs.prelude.finite_sets as finite_sets;
require pvs.prelude.restrict_set_props as restrict_set_props;
require pvs.prelude.extend_set_props as extend_set_props;
require pvs.prelude.function_image_aux as function_image_aux;
require pvs.prelude.function_iterate as function_iterate;
require pvs.prelude.sequences as sequences;
require pvs.prelude.seq_functions as seq_functions;
require pvs.prelude.finite_sequences as finite_sequences;
require pvs.prelude.more_finseq as more_finseq;
require pvs.prelude.ordstruct as ordstruct;
require pvs.prelude.ordinals as ordinals;
require pvs.prelude.lex2 as lex2;
require pvs.prelude.lex3 as lex3;
require pvs.prelude.lex4 as lex4;
require pvs.prelude.list as list;
require pvs.prelude.list_props as list_props;
require pvs.prelude.map_props as map_props;
require pvs.prelude.more_map_props as more_map_props;
require pvs.prelude.filters as filters;
require pvs.prelude.list2finseq as list2finseq;
require pvs.prelude.list2set as list2set;
require pvs.prelude.disjointness as disjointness;
require pvs.prelude.character as character;
require pvs.prelude.strings as strings;
require pvs.prelude.lift as lift;
require pvs.prelude.union as union;
require pvs.prelude.mucalculus as mucalculus;
require pvs.prelude.ctlops as ctlops;
require pvs.prelude.fairctlops as fairctlops;
require pvs.prelude.Fairctlops as Fairctlops;
require pvs.prelude.bit as bit;
require pvs.prelude.bv as bv;
require pvs.prelude.exp2 as exp2;
require pvs.prelude.bv_concat_def as bv_concat_def;
require pvs.prelude.bv_bitwise as bv_bitwise;
require pvs.prelude.bv_nat as bv_nat;
require pvs.prelude.empty_bv as empty_bv;
require pvs.prelude.bv_caret as bv_caret;
require pvs.prelude.mod as mod;
require pvs.prelude.bv_arith_nat_defs as bv_arith_nat_defs;
require pvs.prelude.bv_int_defs as bv_int_defs;
require pvs.prelude.bv_arithmetic_defs as bv_arithmetic_defs;
require pvs.prelude.bv_extend_defs as bv_extend_defs;
require pvs.prelude.integertypes as integertypes;
require pvs.prelude.infinite_sets_def as infinite_sets_def;
require pvs.prelude.finite_sets_of_sets as finite_sets_of_sets;
require pvs.prelude.EquivalenceClosure as EquivalenceClosure;
require pvs.prelude.QuotientDefinition as QuotientDefinition;
require pvs.prelude.KernelDefinition as KernelDefinition;
require pvs.prelude.QuotientKernelProperties as QuotientKernelProperties;
require pvs.prelude.QuotientSubDefinition as QuotientSubDefinition;
require pvs.prelude.QuotientExtensionProperties as QuotientExtensionProperties;
require pvs.prelude.QuotientDistributive as QuotientDistributive;
require pvs.prelude.QuotientIteration as QuotientIteration;
require pvs.prelude.PartialFunctionDefinitions as PartialFunctionDefinitions;
require pvs.prelude.PartialFunctionComposition as PartialFunctionComposition;
require pvs.prelude.stdlang as stdlang;
require pvs.prelude.stdexc as stdexc;
require pvs.prelude.stdcatch as stdcatch;
require pvs.prelude.stdprog as stdprog;
require pvs.prelude.stdglobal as stdglobal;
require pvs.prelude.stdpvs as stdpvs;
require pvs.prelude.stdmath as stdmath;
require pvs.prelude.stdstr as stdstr;
require pvs.prelude.stdio as stdio;
require pvs.prelude.stdfmap as stdfmap;
require pvs.prelude.stdindent as stdindent;
require pvs.prelude.stdtokenizer as stdtokenizer;
require pvs.prelude.stdpvsio as stdpvsio;
require pvs.prelude.stdsys as stdsys;
constant symbol T: Set;

constant symbol U: Set;


opaque symbol fun_TCC1 : Prf (∃ [arrd (U ~> prop) (λ (p: El (U ~> prop)),psub [U] p)] (λ (x: El (arrd (U ~> prop) (λ (p: El (U ~> prop)),psub [U] p))),true)) ≔  begin admitted;

constant symbol fun: El (arrd (U ~> prop) (λ (p: El (U ~> prop)),psub [U] p)) begin admitted;

