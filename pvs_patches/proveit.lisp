(defun proveit ()
  (let* ((proveitversion
          (or (environment-variable "PROVEITVERSION") (format nil "proveit ~a" *prooflite-version*)))
         (context (environment-variable "PROVEITPVSCONTEXT"))
         (proveitarg (environment-variable "PROVEITARG"))
         (pvsfile (let ((name (environment-variable "PROVEITPVSFILE")))
                   (when (and name (string/= name "")) name)))
         (import (let ((envstr (environment-variable "PROVEITLISPIMPORT")))
                  (when envstr (read-from-string envstr))))
         (scripts (let ((envstr (environment-variable "PROVEITLISPSCRIPTS")))
                   (when envstr (read-from-string envstr))))
         (write-scripts (let ((envstr (environment-variable "PROVEITLISPWRITESCRIPTS")))
                         (when envstr (read-from-string envstr))))
         (traces (let ((envstr (environment-variable "PROVEITLISPTRACES")))
                  (when envstr (read-from-string envstr))))
         (force (let ((envstr (environment-variable "PROVEITLISPFORCE")))
                 (when envstr (read-from-string envstr))))
         (autotop (let ((envstr (environment-variable "PROVEITLISPAUTOTOP")))
                   (when envstr (read-from-string envstr))))
         (typecheckonly (let ((envstr (environment-variable "PROVEITLISPTYPECHECK")))
                         (when envstr (read-from-string envstr))))
         (txtproofs (let ((envstr (environment-variable "PROVEITLISPTXTPROOFS")))
                     (when envstr (read-from-string envstr))))
         (texproofs (let ((envstr (environment-variable "PROVEITLISPTEXPROOFS")))
                     (when envstr (read-from-string envstr))))
         (preludext (remove-duplicates
                     (let ((envstr (environment-variable "PROVEITLISPPRELUDEXT")))
                      (when envstr (read-from-string envstr)))
                     :test #'string=))
         (disable (remove-duplicates
                   (let ((envstr (environment-variable "PROVEITLISPDISABLE")))
                    (when envstr (read-from-string envstr)))
                   :test #'string=))
         (enable (remove-duplicates
                  (let ((envstr (environment-variable "PROVEITLISPENABLE")))
                    (when envstr (read-from-string envstr)))
                  :test #'string=))
         (auto-fix? (let ((envstr (environment-variable "PROVEITLISPAUTOFIX")))
                     (when envstr (read-from-string envstr))))
         (default-proof (let ((envstr (environment-variable
                                       "PROVEITLISPDEFAULTPROOFSCRIPT")))
                         (when envstr (read-from-string envstr))))
         (thfs (thfs2list (let ((envstr (environment-variable "PROVEITLISPTHFS")))
                           (when envstr (read-from-string envstr)))))
         (theories (remove-duplicates
                    (let ((envstr (environment-variable "PROVEITLISPTHEORIES")))
                     (when envstr (read-from-string envstr)))
                    :test #'string=))
         (dependencies (environment-variable "PROVEITLISPDEPENDENCIES"))
         (*print-readably* nil)
         (*noninteractive* t)
         (*pvs-verbose* (if traces 3 2))
         (proveit-return-value 0))
    (handler-bind
     ((error #'(lambda (cnd)
                (format t "~%~a~%"
                 (remove-newline
                  (format nil "Error: ~a (~a)" cnd proveitarg)))
                #+allegro
                (when (< 2 *pvs-verbose*)
                  (tpl::zoom-command :from-read-eval-print-loop nil :count t :top t))
                (bye 1))))
     (format t "~%*** ~%*** Processing ~a (~a)~%*** Generated by ~a~%"
      proveitarg (now-today) proveitversion)
      ;; auto-fix
     (when (and auto-fix? (numberp auto-fix?))
      (setq *auto-fix-on-rerun* auto-fix?)
      (format  t "*** Auto-Fix enabled (siblinghood threshold ~a)~%" auto-fix?))
            ;; default proof script
     (when default-proof
      (setq *proof-for-unexpected-branches* default-proof)
      (format  t "*** Using default proof for open branches: ~a~%" default-proof))
     (extra-disable-oracles-but disable enable)
     (let ((orcls (extra-list-oracles)))
      (when orcls
       (format  t "*** Trusted Oracles~%")
       (loop for orcl in orcls
          do (format t "***   ~a: ~a~%"
              (car orcl) (cdr orcl)))))
     (format t "*** ")
     (change-workspace context t)
     (dolist (prelude preludext) (load-prelude-library prelude t))
      ;; generate top if requested
     #+pvsdebug (format t "~&[proveit-init.proveit] pvsfile ~a ~%" pvsfile)
      #+pvsdebug (format t "~&[proveit-init.proveit] autotop ~a ~%" autotop)
      (when autotop
       (handler-case (make-top-file pvsfile)
        (top-already-exists (cnd)
         (format t "~%*** Warning: ~a. Omitting generation.~%" (format nil "~a" cnd)))))
      #+pvsdebug (format t "~&[proveit-init.proveit] after autotop checkpoint~%")
      (when pvsfile
       (let ((*pvs-error-hook*
              (lambda (msg err buff place)
               (declare (ignore buff place))
               (format t "~&Error: ~a - ~a~%" (remove-newline msg) (remove-newline err))
               (bye 1))))
        (typecheck-file pvsfile nil nil nil t)))
      #+pvsdebug (format t "~&[proveit-init.proveit] after typecheck checkpoint~%")
      (save-context)
      (let* ((theory-names (or theories (and pvsfile (theories-in-file pvsfile))))
    ;; prelude files are not registered in theories-in-file
             (theory-names (if theory-names theory-names (tc pvsfile)))
             (pvstheories
              (if import (imported-theories-in-theories theory-names)
               (mapcar #'get-typechecked-theory theory-names)))
             (depfile (pathname (format nil "pvsbin/~a.dep" (or pvsfile "bot")))))
;; check unreachable theories
       #+pvsdebug (format t "~%[proveit-init.proveit] pvsfile ~a import ~a~%" pvsfile import)
       (when (and (string= pvsfile "top") import)
        (let*((files-in-dir
               (loop for f in (directory(pathname "*.pvs")) collect (pathname-name f)))
              (reachable-files
               (loop for th being the hash-values
                     of (pvs-theories (current-workspace)) collect (filename th)))
              (missing-files (set-difference files-in-dir reachable-files :test #'string=)))
          #+pvsdebug (format t "~%[proveit-init.proveit] files-in-dir ~{~a ~}~%" files-in-dir)
          #+pvsdebug (format t "~%[proveit-init.proveit] reachable-files ~{~a ~}~%" reachable-files)
          #+pvsdebug (format t "~%[proveit-init.proveit] missing-files ~{~a ~}~%" missing-files)
          (when missing-files
            (let ((*disable-gc-printout* t))
             (let ((plural? (< 1 (length missing-files))))
              (format t "~&*** Warning: file~:[~;s~] ~{~#[~;~a.pvs~;~a.pvs and ~a.pvs~:;~@{~a.pvs~#[~;, and ~:;, ~]~}~]~} ~:[is~;are~] not reachable from top.pvs~%" plural? missing-files plural?))))))
;; dependencies
       (unless (equal dependencies "nil")
        (let((relative-path-lib-names? (equal dependencies "relative")))
          (with-open-file
            (stream (ensure-directories-exist depfile)
             :direction :output
             :if-exists :supersede
             :if-does-not-exist :create)
            (format stream
             "~{~a~^,~}~%"
             (mapcar #'(lambda (th)
                        (qualified-th-name th relative-path-lib-names?))
              pvstheories))
            (mapc
             #'(lambda (ws)
                (let ((theories-in-ws (loop for th being the hash-keys
                                       in (pvs-files ws)
                                       collect th)))
                  (when theories-in-ws (format stream "[WSS]~a~{~a~^,~}~%"
                                        (qualified-path-name (path ws) relative-path-lib-names?)
                                        theories-in-ws))))
             *all-workspace-sessions*)
           (loop for th in pvstheories
              for idth = (id th)
              do (format stream "~a:~{~a~^,~}~%" (qualified-th-name th relative-path-lib-names?)
                  (mapcar
                      #'(lambda(x)
                         (if (lib-datatype-or-theory? x)
                             (format nil
                              "~a" (qualified-th-name x relative-path-lib-names?))
                           (qualified-th-name x relative-path-lib-names?)))
                      (immediate-theories-in-theory idth)))))))
       (let ((pvstheories
              (remove-if #'(lambda (th) (typep th '(or datatype codatatype)))
               pvstheories)))
        (if typecheckonly
            (if pvsfile (format t "~%File ~a.pvs typechecked~%" pvsfile)
             (format t "~%Typechecked ~a~%" proveitarg))
          (progn
            (when scripts
             (dolist (theory pvstheories)
              (let*((prl-filename (get-prooflite-file-name theory))
                    (prlfile (probe-file
                              (make-pathname :defaults *default-pathname-defaults*
                               :name prl-filename))))
                (when prlfile
                  (pvs-message "Installing proof scripts from ~a into theory ~a.~%"
                   prl-filename (id theory))
                  (install-prooflite-scripts-from-prl-file theory prlfile force))
                (install-prooflite-scripts (filename theory) (id theory) 0 force))))
            (proveit-theories pvstheories force thfs txtproofs texproofs nil
;; if auto-fix?, save proofs
             auto-fix?)
            (setq proveit-return-value
             (proveit-status-proof-theories pvstheories thfs))))
        (save-context)
        (when write-scripts
          (dolist (theory pvstheories)
            (write-all-prooflite-scripts-to-file (format nil "~a" (id theory)))))))
      #+pvsdebug (format t "~&[proveit-init.proveit] proveit-return-value ~a~%" proveit-return-value)
      (bye proveit-return-value))))
