/// Sub-type polymorphism
require open personoj.encodings.lhol
require open personoj.encodings.pvs_cert
require open personoj.encodings.bool_hol
require open personoj.encodings.tuple
require open personoj.encodings.pairs
require open personoj.encodings.prenex

// Returns the top type of any type
symbol Pull: Set → Set
rule Pull (psub {$T} _) ↪ Pull $T

// [pull {t} m] pulls term [t] from its type [t] to the top-type [Pull t]
symbol pull {t: Set} (_: El t): El (Pull t)
rule pull {psub _} $m ↪ pull (fst $m)

// [Comp t u] can be inhabited only if [t] and [u] are convertible top types.
constant symbol Comp : Set → Set → TYPE
constant symbol CompRefl : Π(t: Set), Comp t t
// We can potentiall make [Comp] and [CompRefl] private
definition Equivalent A B ≔ Comp (Pull A) (Pull B)
definition EqvRefl (t: Set) ≔ CompRefl (Pull t)

// [Dive_p t m] generates the proposition gathering all the predicate
// on the path to type [t].
symbol Dive_p (t: Set) (_: El (Pull t)): Bool
// [dive t m h] types term [m: El (Pull t)] as [El t], with [h] the proof that
// [m] validates all predicates generated by [Dive_p t m]. It rewrites to a
// succession of pairs, given a reduction rule below. Proof irrelevant in
// [h] thanks to the reduction into pairs.
symbol dive (t: Set) (m: El (Pull t)) (_: Prf (Dive_p t m)): El t

// Actual computation of [Dive_p]
rule Dive_p (psub {$t} $a) $x
   ↪ (Dive_p $t $x) ∧ (λy: Prf (Dive_p $t $x), $a (dive $t $x y))

/// The two theorems below are needed to split the tccs generated by [dive]
/// into 2: the tcc of the top, and all tccs below it. Let [P] be the TCC
/// generated by [dive], then, morally, [P = below P ∧ top P].

// [below t a m h] provides a proof that [m] validates all predicates up to type
// [t] given that [h] is a proof that [m] validates all predicates up  to type
// [{x: t | a}].
theorem below:
  Prf
  (∀B (λt,
   ∀ {t ~> bool} (λa,
   ∀ {Pull t} (λm,
     Dive_p (psub {t} a) m ⊃ (λ_, Dive_p t m)))))
proof
  // Is mainly the application of the elimination of "and" since
  // [Dive_p (psub a) m] rewrites to [Dive_p t m ∧ a (dive t m h)]
admit

// [top t a m h] provides a proof that [m] validates the tcc [a] so that
// [m] given a proof [h] that [m] can be typed as [psub a].
theorem top:
  Prf
  (∀B (λt,
   ∀ {t ~> bool} (λa,
   ∀ {Pull t} (λm,
   Dive_p (psub {t} a) m ⊃ (λh, a (dive t m (below t a m h)))))))
proof
admit

// Rewrite [dive {x: T | a} m h] to succession of pairs.
rule dive (psub {$t} $a) $m $h
   ↪ pair {$t} {$a} (dive $t $m (below $t $a $m $h)) (top $t $a $m $h)

protected symbol transfer' (t: Set) (u: Set) (_: El t): El u
definition transfer (t: Set) (u: Set) (_: Comp t u) (m: El t) ≔ transfer' t u m

// Erase [transfer] if casting to the same type.
rule transfer' $t $t $m ↪ $m

definition cast {fr_t: Set} (to_t: Set)
                (comp: Equivalent fr_t to_t) (m: El fr_t)
                (tcc: Prf (Dive_p to_t (transfer (Pull fr_t) (Pull to_t)
                                               comp (pull m))))
         ≔ dive to_t (transfer (Pull fr_t) (Pull to_t) comp (pull m)) tcc

// Some rules on top types are needed, we give them for [bool]
rule Pull bool ↪ bool // Can't go above [bool]
with pull bool $x ↪ $x // A term can't be pulled higher than [bool]
rule Dive_p bool _ ↪ true // A term compatible with [bool] can always be [bool]
with dive bool $x _ ↪ $x // Diving to [bool] is immediate
